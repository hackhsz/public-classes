import os
from flask import Flask, render_template, session, redirect, request, url_for, flash
from flask_script import Manager, Shell
from flask_wtf import FlaskForm
from wtforms import StringField, SubmitField, FileField, PasswordField, BooleanField, SelectMultipleField, ValidationError,IntegerField
from wtforms.validators import Required, Length, Email, Regexp, EqualTo
from flask_sqlalchemy import SQLAlchemy
import random
from flask_migrate import Migrate, MigrateCommand
import pdb
# Imports for email from app
from flask_mail import Mail, Message
from threading import Thread
from werkzeug import secure_filename
from werkzeug.security import generate_password_hash, check_password_hash

# Imports for login management
from flask_login import LoginManager, login_required, logout_user, login_user, UserMixin, current_user

# Configure base directory of app
basedir = os.path.abspath(os.path.dirname(__file__))

# Application configurations
app = Flask(__name__)
app.static_folder = 'static'
app.config['SECRET_KEY'] = 'hardtoguessstring'
app.config["SQLALCHEMY_DATABASE_URI"] = os.environ.get('DATABASE_URL') or "postgresql://localhost/hushizhfinal"  # TODO: decide what your new database name will be, and create it in postgresql, before running this new application
# Lines for db setup so it will work as expected
app.config['SQLALCHEMY_COMMIT_ON_TEARDOWN'] = True
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# Set up email config stuff
app.config['MAIL_SERVER'] = 'smtp.googlemail.com'
app.config['MAIL_PORT'] = 587 #default
app.config['MAIL_USE_TLS'] = True
app.config['MAIL_USERNAME'] = os.environ.get('MAIL_USERNAME') # TODO export to your environs -- may want a new account just for this. It's expecting gmail, not umich
app.config['MAIL_PASSWORD'] = os.environ.get('MAIL_PASSWORD')
app.config['MAIL_SUBJECT_PREFIX'] = '[Songs App]'
app.config['MAIL_SENDER'] = 'Admin <>' # TODO fill in email
app.config['ADMIN'] = os.environ.get('ADMIN') or "admin@example.com" # If Admin in environ variable / in prod or this fake email
app.config['HEROKU_ON'] = os.environ.get('HEROKU')

# Set up Flask debug and necessary additions to app
manager = Manager(app)
db = SQLAlchemy(app) # For database use
migrate = Migrate(app, db) # For database use/updating
manager.add_command('db', MigrateCommand) # Add migrate command to manager
mail = Mail(app) # For email sending

# Login configurations setup
login_manager = LoginManager()

collections = db.Table('collections',db.Column('skill_id',db.Integer,db.ForeignKey('skill.id')),db.Column('class_id',db.Integer,db.ForeignKey('class.id')))

class Skillsection(db.Model):
    __tablename__="skillsections"
    id=db.Column(db.Integer,primary_key=True)
    name = db.Column(db.String(500))
    skills = db.relationship('Skill',backref='Skillsection')


    def __repr(self):
        return "This skillsection has a name {}".format(self.name)




class Class(db.Model):
    __tablename__="class"
    id = db.Column(db.Integer,primary_key=True)
   # class_name = db.Column(db.String(200),unique=True))                        
    class_number =db.Column(db.Integer,unique=True)
    skill = db.relationship('Skill',secondary = collections,backref=db.backref('class',lazy='dynamic'),lazy='dynamic')


    def __repr__(self):
        return "This class is {}".format(self.class_name)



class Skill(db.Model):
    __tablename__="skill"
    id = db.Column(db.Integer,primary_key=True)
    name = db.Column(db.String(300),unique=True)
    level = db.Column(db.String(500))
    skillsections_id = db.Column(db.Integer,db.ForeignKey("skillsections.id"))
                                

    def __repr__(self):
        return "This skill is {}".format(self.name)

class SkillForm(FlaskForm):
    skill_name = StringField("What is the skill name of this",validators=[Required()])
    level = StringField("What is the level of this skill",validators=[Required()])
    section_name=StringField("Name of this class?")

    submit=SubmitField("Submit this Skill")


class ClassForm(FlaskForm):
#    skills= Skill.query.all()                                                  

    #all_skill_name = [(eachs.skill_name,l) for eachs in skills for l in levels\
                                                                            
    class_name=StringField("Nname of this class?", validators=[Required()])
    class_number=IntegerField("What is the class number?", validators=[Required()])

                                                             
    submit= SubmitField('Submit')





def get_or_create_skillsection(db_session,section_name):
    skillsection = db.session.query(Skillsection).filter_by(name=section_name).first()
    if skillsection:
        return skillsection
    else:
        skill_sec = Skillsection(name=section_name)
        db_session.add(skill_sec)
        db_session.commit()
        return skill_sec





def get_skill_by_name(skill_name):
    skill = Skill.query.filter_by(name=skill_name).first()
    return skill

def get_or_create_skill(db_session,skill_name,lev,skillsectionname=[]):
    skill = db.session.query(Skill).filter_by(name=skill_name).first()
    if skill:
        return skill
    else:
        #new_section = get_or_create_skillsection(db_session,skillsectionname)  
        newskill=Skill(name=skill_name,level=lev)
        for item in skillsectionname:
            newitem = get_or_create_skillsection(db_session,item)
            newskill.skillsections.append(newitem)

        db_session.add(newskill)
        db_session.commit()
        return newskill

def get_or_create_class(db_session,class_num,list_of_skills):
   newclass= db_session.query(Class).filter_by(class_number=class_num).first()
   if newclass:
       return newclass
   else:
       newclass = Class(class_number=class_num)
       for item in list_of_skills:
           newclass.skill.append(item)
       db_session.add(newclass)
       db_session.commmit(newclass)
       return newclass


@app.route('/',methods=['GET','POST'])
def index():
    form = SkillForm()
    skills = Skill.query.all()
    length_skills = len(skills)
    print("test0")
    #if form.validate_on_submit():
    if request.method == 'POST':
        print("validated")
        if db.session.query(Skill).filter_by(name=form.skill_name.data).first():
            flash("you have this skill already")
        else:
            newlist=[]
        #pdb.set_trace()
            for item in list(form.section_name.data.split(",")):
                newlist.append(item.strip("#"))
            temp=get_or_create_skill(db.session,form.skill_name.data,form.level.data,newlist)
            print(temp)
        return redirect(url_for('see_all_skills'))
    print("test1")
    return render_template('index.html',form=form,num_skills=length_skills)


@app.route('/all_skills')
def see_all_skills():
    all_skills=[]
    skills = Skill.query.all()
    for skill in skills:
        skillsec = Skillsection.query.filter_by(id=skill.skillsections_id).first()
        all_skills.append((skill.name,skillsec.name))
    return render_template('all_skill.html',all_skills=all_skills)



if __name__ == '__main__':
    db.create_all()
    manager.run()













